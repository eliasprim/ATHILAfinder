# Tool to detect lineage-specific LTR retrotransposon based on their PBS and PPT signatures 

# Follow the installation instructions on the ATHILAfinder GitHub page: https://github.com/eliasprim/ATHILAfinder

start=$(date +%s) 

echo "Running ATHILAfinder_v1.0 on cluster: $(hostname) at $(date)"


echo "Assembly: $1";

echo "PBS signature: $2";

echo "PPT signature: $3";

echo "Searching Regions (bedtools window): $4";

echo "Minimum Internal Length: $5";

echo "Maximum Internal Length: $6";

echo "Extend Internal: $7";

echo "Length of Start/End Oligomers: $8";

echo "Mismatches of Start/End Oligomers: $9";

echo "Minimum LTR Length: ${10}";

echo "Maximum LTR Length: ${11}";

echo "Species code: ${12}";

echo "LTR retrotransposon lineage: ${13}"

echo "BLAST FULL-LENGTH Coverage (Minimum value): ${14}";

echo "BLAST Minimum Signature Coordinate: ${15}"

echo "BLAST Maximum Signature Coordinate: ${16}"

echo "BLAST PBS Signature Mismatches: ${17}"

echo "BLAST PPT Signature Mismatches: ${18}"

echo "BLAST Mismatches of Start/End Oligomers: ${19}";

echo "BLAST SOLO-LTR Coverage (Minimum value): ${20}";

echo "ORF HMM DATABASE: ${21}";

echo "HMMSCAN E-VALUE: ${22}";



echo "STEP 1: Scan the genome for the lineage-specific PBS and PPT signatures";

# STEP 1: VMATCH: FIND THE PBS AND PPT JUNCTIONS AND PREPARE THE OUTPUTS FOR THE BEDTOOLS WINDOW STEP

mkvtree -dna -pl -allout -db $1

vmatch -q inputs/$2 -complete -h 3 -d -p -s -v -showdesc 100 -noevalue -noidentity -noscore $1 > $1.PBS.vmatch

vmatch -q inputs/$3 -complete -h 3 -d -p -s -v -showdesc 100 -noevalue -noidentity -noscore $1 > $1.PPT.vmatch 

Rscript scripts/vmatch1_2_bed1.R $1.PBS.vmatch $1.PBS.vmatch_FULL_D.bed $1.PBS.vmatch_FULL_P.bed 

Rscript scripts/vmatch1_2_bed1.R $1.PPT.vmatch $1.PPT.vmatch_FULL_D.bed $1.PPT.vmatch_FULL_P.bed

Rscript scripts/unique_pbs.R $1.PBS.vmatch_FULL_D.bed $1.PBS.vmatch_FULL_D_UNIQUE.bed 

Rscript scripts/unique_pbs.R $1.PBS.vmatch_FULL_P.bed $1.PBS.vmatch_FULL_P_UNIQUE.bed

Rscript scripts/unique_pbs.R $1.PPT.vmatch_FULL_D.bed $1.PPT.vmatch_FULL_D_UNIQUE.bed

Rscript scripts/unique_pbs.R $1.PPT.vmatch_FULL_P.bed $1.PPT.vmatch_FULL_P_UNIQUE.bed

echo "STEP 1: Completed";


echo "STEP 2: Match PBS and PPT signatures to make the primitive internal domains of the elements";

# STEP 2: BEDTOOLS WINDOW: MATCH PBS AND PPT SIGNATURES TO MAKE THE 'PRIMITIVE' INTERNAL DOMAIN OF LTR RETROTRANSPOSONS AND PREPARE BED INPUT FOR BEDTOOLS INTERSECT 

# D 
bedtools window -a $1.PBS.vmatch_FULL_D_UNIQUE.bed -b $1.PPT.vmatch_FULL_D_UNIQUE.bed -l 0 -r $4 > $1.PBS_2_PPT_FULL_D_r10k.txt 

bedtools window -a $1.PBS.vmatch_FULL_D_UNIQUE.bed -b $1.PPT.vmatch_FULL_D_UNIQUE.bed -l 0 -r $4 -v > $1.PBS_2_PPT_FULL_D_r10k_v.txt 

bedtools window -a $1.PPT.vmatch_FULL_D_UNIQUE.bed -b $1.PBS.vmatch_FULL_D_UNIQUE.bed -l $4 -r 0 -v > $1.PPT_2_PBS_FULL_D_l10k_v.txt 

# P 
bedtools window -a $1.PPT.vmatch_FULL_P_UNIQUE.bed -b $1.PBS.vmatch_FULL_P_UNIQUE.bed -l 0 -r $4 > $1.PPT_2_PBS_FULL_P_r10k.txt 

bedtools window -a $1.PPT.vmatch_FULL_P_UNIQUE.bed -b $1.PBS.vmatch_FULL_P_UNIQUE.bed -l 0 -r $4 -v > $1.PPT_2_PBS_FULL_P_r10k_v.txt 

bedtools window -a $1.PBS.vmatch_FULL_P_UNIQUE.bed -b $1.PPT.vmatch_FULL_P_UNIQUE.bed -l $4 -r 0 -v > $1.PBS_2_PPT_FULL_P_l10k_v.txt


Rscript scripts/vmatch1bed2_2_intersect.R $1.PBS_2_PPT_FULL_D_r10k.txt $1.PBS_2_PPT_FULL_D_r10k_v.txt $1.PPT_2_PBS_FULL_D_l10k_v.txt $1.PBS_2_PPT_D_EVERYTHING.txt $1.PBS_2_PPT_D_DISTANCE.txt $5 $6 $1.PBS_2_PPT_D_INTERSECT.bed $1.PBS_2_PPT_D_REJECTED.bed

Rscript scripts/vmatch1bed2_2_intersect.R $1.PPT_2_PBS_FULL_P_r10k.txt $1.PPT_2_PBS_FULL_P_r10k_v.txt $1.PBS_2_PPT_FULL_P_l10k_v.txt $1.PPT_2_PBS_P_EVERYTHING.txt $1.PPT_2_PBS_P_DISTANCE.txt $5 $6 $1.PPT_2_PBS_P_INTERSECT.bed $1.PPT_2_PBS_P_REJECTED.bed

cat $1.PBS_2_PPT_D_EVERYTHING.txt $1.PPT_2_PBS_P_EVERYTHING.txt > $1.PBSPPT_DP_EVERYTHING.txt

cat $1.PBS_2_PPT_D_REJECTED.bed $1.PPT_2_PBS_P_REJECTED.bed > $1.PBSPPT_DP_REJECTED.bed

cat $1.PBS_2_PPT_D_DISTANCE.txt $1.PPT_2_PBS_P_DISTANCE.txt > $1.PBS_PPT_DP_DISTANCE.txt

cat $1.PBS.vmatch_FULL_D_UNIQUE.bed $1.PPT.vmatch_FULL_D_UNIQUE.bed > $1.OLIGOMERS_PBS_N_PPT_FULL_D_INTERSECT.bed 

cat $1.PBS.vmatch_FULL_P_UNIQUE.bed $1.PPT.vmatch_FULL_P_UNIQUE.bed > $1.OLIGOMERS_PBS_N_PPT_FULL_P_INTERSECT.bed 

echo "STEP 2: Completed";


echo "STEP 3: Scan the internal domains of the elements for PBS and PPT signatures in the anti-sense strand";

# STEP 3: BEDTOOLS INTERSECT: CHECK FOR PBS AND PPT INSIDE THE INTERNAL REGION (ANTI-SENSE STRAND) OF THE LTR RETROTRANSPOSONS 

# D
bedtools intersect -a $1.PBS_2_PPT_D_INTERSECT.bed -b $1.OLIGOMERS_PBS_N_PPT_FULL_P_INTERSECT.bed -wa > $1.INTERSECT_D_2_P.txt

python3 scripts/rmv_intersect.py $1.INTERSECT_D_2_P.txt $1.PBS_2_PPT_D_INTERSECT.bed $1.PBS_2_PPT_D_INTERSECT_NEW.bed

# P
bedtools intersect -a $1.PPT_2_PBS_P_INTERSECT.bed -b $1.OLIGOMERS_PBS_N_PPT_FULL_D_INTERSECT.bed -wa > $1.INTERSECT_P_2_D.txt

python3 scripts/rmv_intersect.py $1.INTERSECT_P_2_D.txt $1.PPT_2_PBS_P_INTERSECT.bed $1.PPT_2_PBS_P_INTERSECT_NEW.bed

cat $1.INTERSECT_D_2_P.txt $1.INTERSECT_P_2_D.txt > $1.INTERSECT_DP_2_PD_REJECTED.bed

cat $1.OLIGOMERS_PBS_N_PPT_FULL_D_INTERSECT.bed $1.OLIGOMERS_PBS_N_PPT_FULL_P_INTERSECT.bed > $1.ALL_OLIGOMERS_PBS_N_PPT_FULL_DP.bed

sort -k1,1V $1.ALL_OLIGOMERS_PBS_N_PPT_FULL_DP.bed > $1.ALL_OLIGOMERS_PBS_N_PPT_FULL_DP_SORTED.bed

cat $1.PBS_2_PPT_D_INTERSECT_NEW.bed $1.PPT_2_PBS_P_INTERSECT_NEW.bed > $1.ALL.PBSPPT_DP_WINDOW2.bed

sort -k1,1V $1.ALL.PBSPPT_DP_WINDOW2.bed > $1.ALL.PBSPPT_DP_WINDOW2_SORTED.bed

echo "STEP 3: Completed";


echo "STEP 4: Scan the extended elements for PBS and PPT signatures outside their internal region";

# STEP 4: BEDTOOLS WINDOW: CHECK FOR PBS AND PPT SIGNATURES OUTSIDE THE INTERNAL REGION (SPECIFIC RANGE -- HARDCODED),
# 		  PLUS FILTERING OF THE BEDTOOLS WINDOW OUTPUT (REMOVING LTR RETROTRANSPOSONS WITH SIGNATURES CLOSE TO THEM) AND KEEPING THE PROXIMAL ELEMENTS AND ORPHAN SIGNATURES 	

bedtools window -a $1.ALL.PBSPPT_DP_WINDOW2_SORTED.bed -b $1.ALL_OLIGOMERS_PBS_N_PPT_FULL_DP_SORTED.bed -w 1000 > $1.ALL_PBSPPT_DP_OUTSIDE_INTERNAL.bed

Rscript scripts/window2_2_clean_prox_orphan.R $1.ALL_PBSPPT_DP_OUTSIDE_INTERNAL.bed $1.ALL.PBSPPT_DP_OUTSIDE_INTERNAL_REJECTED.bed $1.ALL.PBSPPT_DP_WINDOW2_SORTED.bed $1.ALL.PBSNPPT_DP_OUTSIDE_INTERNAL_CLEAN.bed $1.PBSNPPT_D_OUTSIDE_INTERNAL_CLEAN.bed $1.PPTNPBS_P_OUTSIDE_INTERNAL_CLEAN.bed $1.ALL.PBSNPPT_DP_OUTSIDE_INTERNAL_PROXIMAL_ELEMENTS.bed $1.ALL.PBSNPPT_DP_OUTSIDE_INTERNAL_ORPHAN_OLIGOMERS.bed

echo "STEP 4: Completed";


echo "STEP 5: Extend the internal elements and search for the start and end oligomers in them";

# STEP 5: EXTEND 'INTERNALS' AND SEPARATE STRANDS TO RETRIEVE THE FASTA FILES, WHICH WILL BE USED AS INPUTS IN SEARCHING FOR THE START/END OLIGOMERS IN THOSE WITH VMATCH

Rscript scripts/extended_startend_oligos.R $1.ALL.PBSNPPT_DP_OUTSIDE_INTERNAL_CLEAN.bed $7 $1.ALL.PBSNPPT_D_EXTENDED_INTERNAL_CLEAN.bed $1.ALL.PBSNPPT_P_EXTENDED_INTERNAL_CLEAN.bed $8 $1.ALL.PBSNPPT_D_POTENTIAL_STARTS.bed $1.ALL.PBSNPPT_D_POTENTIAL_ENDS.bed $1.ALL.PBSNPPT_P_POTENTIAL_STARTS.bed $1.ALL.PBSNPPT_P_POTENTIAL_ENDS.bed

cat $1.ALL.PBSNPPT_D_EXTENDED_INTERNAL_CLEAN.bed $1.ALL.PBSNPPT_P_EXTENDED_INTERNAL_CLEAN.bed > $1.ALL.PBSNPPT_DP_EXTENDED_INTERNAL_CLEAN.bed

# D
bedtools getfasta -fi $1 -bed $1.PBSNPPT_D_OUTSIDE_INTERNAL_CLEAN.bed -fo $1_OUTSIDE_D_ELEMENTS.fasta

bedtools getfasta -fi $1 -bed $1.ALL.PBSNPPT_D_EXTENDED_INTERNAL_CLEAN.bed -fo $1_EXTENDED_D_ELEMENTS.fasta

bedtools getfasta -fi $1 -bed $1.ALL.PBSNPPT_D_POTENTIAL_STARTS.bed -nameOnly -fo $1.ALL.PBSNPPT_D_POTENTIAL_STARTS.fasta

awk 'BEGIN{RS=">"}{print ""$1"\t"$4;}' $1.ALL.PBSNPPT_D_POTENTIAL_STARTS.fasta | tail -n+2 > $1.ALL.PBSNPPT_D_POTENTIAL_STARTS.txt

python3 scripts/keep_unique_seqs.py $1.ALL.PBSNPPT_D_POTENTIAL_STARTS.fasta $1.ALL.PBSNPPT_D_POTENTIAL_STARTS_UNIQUE.fasta

bedtools getfasta -fi $1 -bed $1.ALL.PBSNPPT_D_POTENTIAL_ENDS.bed -nameOnly -fo $1.ALL.PBSNPPT_D_POTENTIAL_ENDS.fasta

awk 'BEGIN{RS=">"}{print ""$1"\t"$4;}' $1.ALL.PBSNPPT_D_POTENTIAL_ENDS.fasta | tail -n+2 > $1.ALL.PBSNPPT_D_POTENTIAL_ENDS.txt

python3 scripts/keep_unique_seqs.py $1.ALL.PBSNPPT_D_POTENTIAL_ENDS.fasta $1.ALL.PBSNPPT_D_POTENTIAL_ENDS_UNIQUE.fasta

# P
bedtools getfasta -fi $1 -bed $1.PPTNPBS_P_OUTSIDE_INTERNAL_CLEAN.bed -fo $1_OUTSIDE_P_ELEMENTS.fasta

python3 scripts/revcom_auto.py $1_OUTSIDE_P_ELEMENTS.fasta

rm $1_OUTSIDE_P_ELEMENTS.fasta_ml.fasta

mv $1_OUTSIDE_P_ELEMENTS.fasta_sl.fasta $1_OUTSIDE_P_ELEMENTS.fasta 


bedtools getfasta -fi $1 -bed $1.ALL.PBSNPPT_P_EXTENDED_INTERNAL_CLEAN.bed -fo $1_EXTENDED_P_ELEMENTS.fasta

python3 scripts/revcom_auto.py $1_EXTENDED_P_ELEMENTS.fasta

rm $1_EXTENDED_P_ELEMENTS.fasta_ml.fasta

mv $1_EXTENDED_P_ELEMENTS.fasta_sl.fasta $1_EXTENDED_P_ELEMENTS.fasta


bedtools getfasta -fi $1 -bed $1.ALL.PBSNPPT_P_POTENTIAL_STARTS.bed -nameOnly -fo $1.ALL.PBSNPPT_P_POTENTIAL_STARTS.fasta

python3 scripts/revcom_auto.py $1.ALL.PBSNPPT_P_POTENTIAL_STARTS.fasta

rm $1.ALL.PBSNPPT_P_POTENTIAL_STARTS.fasta_ml.fasta

mv $1.ALL.PBSNPPT_P_POTENTIAL_STARTS.fasta_sl.fasta $1.ALL.PBSNPPT_P_POTENTIAL_STARTS.fasta

awk 'BEGIN{RS=">"}{print ""$1"\t"$4;}' $1.ALL.PBSNPPT_P_POTENTIAL_STARTS.fasta | tail -n+2 > $1.ALL.PBSNPPT_P_POTENTIAL_STARTS.txt

python3 scripts/keep_unique_seqs.py $1.ALL.PBSNPPT_P_POTENTIAL_STARTS.fasta $1.ALL.PBSNPPT_P_POTENTIAL_STARTS_UNIQUE.fasta


bedtools getfasta -fi $1 -bed $1.ALL.PBSNPPT_P_POTENTIAL_ENDS.bed -nameOnly -fo $1.ALL.PBSNPPT_P_POTENTIAL_ENDS.fasta

python3 scripts/revcom_auto.py $1.ALL.PBSNPPT_P_POTENTIAL_ENDS.fasta

rm $1.ALL.PBSNPPT_P_POTENTIAL_ENDS.fasta_ml.fasta

mv $1.ALL.PBSNPPT_P_POTENTIAL_ENDS.fasta_sl.fasta $1.ALL.PBSNPPT_P_POTENTIAL_ENDS.fasta

awk 'BEGIN{RS=">"}{print ""$1"\t"$4;}' $1.ALL.PBSNPPT_P_POTENTIAL_ENDS.fasta | tail -n+2 > $1.ALL.PBSNPPT_P_POTENTIAL_ENDS.txt

python3 scripts/keep_unique_seqs.py $1.ALL.PBSNPPT_P_POTENTIAL_ENDS.fasta $1.ALL.PBSNPPT_P_POTENTIAL_ENDS_UNIQUE.fasta


cat $1_OUTSIDE_D_ELEMENTS.fasta $1_OUTSIDE_P_ELEMENTS.fasta > $1_OUTSIDE_DP_ELEMENTS.fasta

cat $1.ALL.PBSNPPT_D_POTENTIAL_STARTS.txt $1.ALL.PBSNPPT_P_POTENTIAL_STARTS.txt > $1.ALL.PBSNPPT_DP_POTENTIAL_STARTS.txt

cat $1.ALL.PBSNPPT_D_POTENTIAL_ENDS.txt $1.ALL.PBSNPPT_P_POTENTIAL_ENDS.txt > $1.ALL.PBSNPPT_DP_POTENTIAL_ENDS.txt

echo "STEP 5: Completed";


echo "STEP 6: Identify the edges of the extended elements using signature-based oligomers";

# STEP 6: RUN VMATCH TO FIND THE START/END OLIGOMERS IN THE EXTENDED 'INTERNALS'. ALSO, ANALYSE VMATCH OUTPUTS TO GET THE FULL-LENGTH ELEMENTS AND SEARCH FOR START/END OLIGOMERS IN SPECIFIC "LTR" REGIONS.
# 		  MAXIMUM OR MINIMUM LTR LENGTH, TAKES THE FIRST OR LAST START/END OLIGOMER IN LTRS RESPECTIVELY. 
# 		  PLUS CONCATENATE ALL THE REJECTED ELEMENTS FROM PREVIOUS STEP INTO ONE FILE   

# D
mkvtree -dna -pl -allout -db $1_EXTENDED_D_ELEMENTS.fasta

vmatch -q $1.ALL.PBSNPPT_D_POTENTIAL_STARTS_UNIQUE.fasta -complete -h $9 -d -s -v -showdesc 100 -noevalue -noidentity -noscore $1_EXTENDED_D_ELEMENTS.fasta > $1_SPECIFIC_START_D_mis$9.vmatch

vmatch -q $1.ALL.PBSNPPT_D_POTENTIAL_ENDS_UNIQUE.fasta -complete -h $9 -d -s -v -showdesc 100 -noevalue -noidentity -noscore $1_EXTENDED_D_ELEMENTS.fasta > $1_SPECIFIC_END_D_mis$9.vmatch

# P
mkvtree -dna -pl -allout -db $1_EXTENDED_P_ELEMENTS.fasta

vmatch -q $1.ALL.PBSNPPT_P_POTENTIAL_STARTS_UNIQUE.fasta -complete -h $9 -d -s -v -showdesc 100 -noevalue -noidentity -noscore $1_EXTENDED_P_ELEMENTS.fasta > $1_SPECIFIC_START_P_mis$9.vmatch

vmatch -q $1.ALL.PBSNPPT_P_POTENTIAL_ENDS_UNIQUE.fasta -complete -h $9 -d -s -v -showdesc 100 -noevalue -noidentity -noscore $1_EXTENDED_P_ELEMENTS.fasta > $1_SPECIFIC_END_P_mis$9.vmatch


Rscript scripts/vmatch2_2_fulllengthbed_element_specific_start_end_DP_terminal.R $1_SPECIFIC_START_D_mis$9.vmatch $1_SPECIFIC_START_P_mis$9.vmatch ${10} ${11} $1.ALL.PBSNPPT_DP_POTENTIAL_STARTS.txt $1_SPECIFIC_END_D_mis$9.vmatch $1_SPECIFIC_END_P_mis$9.vmatch $1.ALL.PBSNPPT_DP_POTENTIAL_ENDS.txt $1.D_FULLLENGTH.bed $1.P_FULLLENGTH.bed $1.ALL.PBSNPPT_DP_EXTENDED_INTERNAL_CLEAN.bed $1.ALL.PBSNPPT_DP_EXTENDED_INTERNAL_CLEAN_REJECTED.bed 

cat $1.D_FULLLENGTH.bed $1.P_FULLLENGTH.bed > $1.DP_FULLLENGTH.bed

sort -k1,1V $1.DP_FULLLENGTH.bed > $1.DP_FULLLENGTH_SORTED.bed

cat $1.PBSPPT_DP_REJECTED.bed $1.INTERSECT_DP_2_PD_REJECTED.bed $1.ALL.PBSPPT_DP_OUTSIDE_INTERNAL_REJECTED.bed $1.ALL.PBSNPPT_DP_EXTENDED_INTERNAL_CLEAN_REJECTED.bed > $1.ALL.DP_REJECTED_ELEMENTS.bed

echo "STEP 6: Completed";


echo "STEP 7: Break full-length elements into LTRs and internal domains";

# STEP 7: MAKE BED FILES FOR THE 5', 3' LTRs AND THE INTERNAL REGIONS AND GET THEIR FASTA SEQUENCES. ALSO RENAME THEIR IDS TO MORE UNIVERSAL ONES (SPECIES-CHR-START-END-STRAND_LINEAGE).   

Rscript scripts/get_ltr_internal_bed.R $1.ALL.PBSNPPT_D_EXTENDED_INTERNAL_CLEAN.bed $1.D_FULLLENGTH.bed $1.D_5LTR.bed $1.D_3LTR.bed $1.D_INTERNAL.bed $1.ALL.PBSNPPT_P_EXTENDED_INTERNAL_CLEAN.bed $1.P_FULLLENGTH.bed $1.P_5LTR.bed $1.P_3LTR.bed $1.P_INTERNAL.bed

# D
bedtools getfasta -fi $1 -bed $1.D_FULLLENGTH.bed -fo $1.D_FULLLENGTH.fasta

bedtools getfasta -fi $1 -bed $1.D_5LTR.bed -fo $1.D_5LTR.fasta

bedtools getfasta -fi $1 -bed $1.D_3LTR.bed -fo $1.D_3LTR.fasta

bedtools getfasta -fi $1 -bed $1.D_INTERNAL.bed -fo $1.D_INTERNAL.fasta

# P
bedtools getfasta -fi $1 -bed $1.P_FULLLENGTH.bed -fo $1.P_FULLLENGTH.fasta

python3 scripts/revcom_auto2.py $1.P_FULLLENGTH.fasta

rm $1.P_FULLLENGTH.fasta_ml.fasta

mv $1.P_FULLLENGTH.fasta_sl.fasta $1.P_FULLLENGTH.fasta 


bedtools getfasta -fi $1 -bed $1.P_5LTR.bed -fo $1.P_5LTR.fasta

python3 scripts/revcom_auto2.py $1.P_5LTR.fasta

rm $1.P_5LTR.fasta_ml.fasta

mv $1.P_5LTR.fasta_sl.fasta $1.P_5LTR.fasta 


bedtools getfasta -fi $1 -bed $1.P_3LTR.bed -fo $1.P_3LTR.fasta

python3 scripts/revcom_auto2.py $1.P_3LTR.fasta

rm $1.P_3LTR.fasta_ml.fasta

mv $1.P_3LTR.fasta_sl.fasta $1.P_3LTR.fasta 


bedtools getfasta -fi $1 -bed $1.P_INTERNAL.bed -fo $1.P_INTERNAL.fasta

python3 scripts/revcom_auto2.py $1.P_INTERNAL.fasta

rm $1.P_INTERNAL.fasta_ml.fasta

mv $1.P_INTERNAL.fasta_sl.fasta $1.P_INTERNAL.fasta 


cat $1.D_FULLLENGTH.fasta $1.P_FULLLENGTH.fasta > $1.DP_FULLLENGTH.fasta

cat $1.D_5LTR.fasta $1.P_5LTR.fasta > $1.DP_5LTR.fasta

cat $1.D_3LTR.fasta $1.P_3LTR.fasta > $1.DP_3LTR.fasta

cat $1.D_INTERNAL.fasta $1.P_INTERNAL.fasta > $1.DP_INTERNAL.fasta


cat $1.D_5LTR.bed $1.P_5LTR.bed > $1.DP_5LTR.bed

cat $1.D_3LTR.bed $1.P_3LTR.bed > $1.DP_3LTR.bed

cat $1.D_INTERNAL.bed $1.P_INTERNAL.bed > $1.DP_INTERNAL.bed


Rscript scripts/fix_names.R $1.DP_FULLLENGTH.bed ${12} ${13} $1.DP_FULLLENGTH_RENAME.txt $1.DP_FULLLENGTH_RENAMED.bed $1.D_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.bed $1.P_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.bed $1.D_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.bed $1.P_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.bed $1.DP_5LTR.bed $1.DP_5LTR_RENAME.txt $1.DP_5LTR_RENAMED.bed $1.DP_3LTR.bed $1.DP_3LTR_RENAME.txt $1.DP_3LTR_RENAMED.bed $1.DP_INTERNAL.bed $1.DP_INTERNAL_RENAME.txt $1.DP_INTERNAL_RENAMED.bed

perl scripts/rename.pl $1.DP_FULLLENGTH_RENAME.txt $1.DP_FULLLENGTH.fasta > $1.DP_FULLLENGTH_RENAMED.fasta

perl scripts/rename.pl $1.DP_5LTR_RENAME.txt $1.DP_5LTR.fasta > $1.DP_5LTR_RENAMED.fasta

perl scripts/rename.pl $1.DP_3LTR_RENAME.txt $1.DP_3LTR.fasta > $1.DP_3LTR_RENAMED.fasta

perl scripts/rename.pl $1.DP_INTERNAL_RENAME.txt $1.DP_INTERNAL.fasta > $1.DP_INTERNAL_RENAMED.fasta

echo "STEP 7: Completed";



echo "STEP 8: Homology-based detection of full-length elements using BLAST and break them into LTRs and internal domains relying on their signatures and signature-based oligomers";

# STEP 8: MASK FULL-LENGTH ELEMENTS IN THE GENOME AND RUN BLAST TO FIND OTHER POTENTIAL FULL-LENGTH ELEMENTS AND SEARCH FOR PBS AND PPT SIGNATURES IN ORDER TO FIND THE LTR AND THE INTERNAL DOMAINS OF THESE TEKAY ELEMENTS

awk '/^>/ {if (seq) {print header"\t"length(seq)}; header=substr($0,2); seq=""; next} {seq=seq $0} END {if (seq) print header"\t"length(seq)}' $1.DP_FULLLENGTH_RENAMED.fasta > $1.DP_FULLLENGTH_RENAMED_LENGTH.txt

bedtools maskfasta -fi $1 -bed $1.DP_FULLLENGTH_RENAMED.bed -fo $1_MASKED.fasta

formatdb -i $1_MASKED.fasta -p F -o T -n $1_masked

blastall -p blastn -i $1.DP_FULLLENGTH_RENAMED.fasta -d $1_masked -e 10e-180 -F F -a 7 -m 8 > $1.FL_AGAINST_MG_BLAST_OUTPUT.txt

Rscript scripts/blast_output_analysis.R $1.FL_AGAINST_MG_BLAST_OUTPUT.txt $1.DP_FULLLENGTH_RENAMED_LENGTH.txt ${14} ${13} ${12} $1.D_FULLLENGTH_BLAST_NONOVERLAPPING.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.bed $1.DP_FULLLENGTH_BLAST_OVERLAPPING.bed


huge_red_flag=0  # Flag to track if any file is empty

file111="$1.D_FULLLENGTH_BLAST_NONOVERLAPPING.bed"
file222="$1.P_FULLLENGTH_BLAST_NONOVERLAPPING.bed"

# Check if either file is empty or missing
if [ ! -s "$file111" ] || [ ! -s "$file222" ]; then
    echo "One or both files are empty or missing."
    huge_red_flag=1
else
    echo "Processing $file111 and $file222..."
    
    cat $1.D_FULLLENGTH_BLAST_NONOVERLAPPING.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING.bed > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING.bed

	sort -k1,1V $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING.bed > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SORTED.bed

	bedtools getfasta -fi $1 -bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING.bed -nameOnly -fo $1.D_FULLLENGTH_BLAST_NONOVERLAPPING.fasta 

	bedtools getfasta -fi $1 -bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING.bed -nameOnly -fo $1.P_FULLLENGTH_BLAST_NONOVERLAPPING.fasta

	python3 scripts/revcom_auto2.py $1.P_FULLLENGTH_BLAST_NONOVERLAPPING.fasta

	rm $1.P_FULLLENGTH_BLAST_NONOVERLAPPING.fasta_ml.fasta

	mv $1.P_FULLLENGTH_BLAST_NONOVERLAPPING.fasta_sl.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING.fasta 

	cat $1.D_FULLLENGTH_BLAST_NONOVERLAPPING.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING.fasta > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING.fasta

	mkvtree -dna -pl 5 -allout -db $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING.fasta

	vmatch -q inputs/$2 -complete -h 8 -d -p -s -v -showdesc 100 -noevalue -noidentity -noscore $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING.fasta > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_PBS.vmatch

	vmatch -q inputs/$3 -complete -h 8 -d -p -s -v -showdesc 100 -noevalue -noidentity -noscore $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING.fasta > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_PPT.vmatch

	# awk 'BEGIN{FS="[> ]"} /^>/{val=$4;next}  {print val"\t"length($0)}' $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING.fasta > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_LENGTH.txt

	awk '/^>/ {if (seq) {print header"\t"length(seq)}; header=substr($0,2); seq=""; next} {seq=seq $0} END {if (seq) print header"\t"length(seq)}' $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING.fasta > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_LENGTH.txt

	Rscript scripts/vmatch_fl_blast_ext_pos_st_en.R $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_LENGTH.txt $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_PBS.vmatch ${15} ${16} $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_PPT.vmatch ${17} ${18} ${12} $8 $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.bed

fi

# If any file was empty, create the output files as empty
if [ "$huge_red_flag" -eq 1 ]; then
    touch $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING.bed $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SORTED.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING.fasta $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_PBS.vmatch $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_PPT.vmatch $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_LENGTH.txt $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.bed
    echo "Created empty files: $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING.bed $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SORTED.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING.fasta $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_PBS.vmatch $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_PPT.vmatch $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_LENGTH.txt $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.bed"
fi



# STEP 14b: GET THE FASTA SEQUENCES (BEDTOOLS) BY USING THE BED FILES FROM THE PREVIOUS STEP (INTERNAL AND EXTENDED)

# D
bedtools getfasta -fi $1 -bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.bed -fo $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.fasta

bedtools getfasta -fi $1 -bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed -fo $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta

bedtools getfasta -fi $1 -bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.bed -name -fo $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.fasta

awk 'BEGIN{RS=">"}{print ""$1"\t"$4;}' $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.fasta | tail -n+2 > $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.txt

python3 scripts/keep_unique_seqs.py $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.fasta $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS_UNIQUE.fasta

bedtools getfasta -fi $1 -bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.bed -name -fo $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.fasta

awk 'BEGIN{RS=">"}{print ""$1"\t"$4;}' $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.fasta | tail -n+2 > $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.txt

python3 scripts/keep_unique_seqs.py $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.fasta $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS_UNIQUE.fasta

# P
bedtools getfasta -fi $1 -bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.bed -fo $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.fasta

python3 scripts/revcom_auto.py $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.fasta

rm $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.fasta_ml.fasta

mv $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.fasta_sl.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.fasta


bedtools getfasta -fi $1 -bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed -fo $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta

python3 scripts/revcom_auto.py $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta

rm $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta_ml.fasta

mv $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta_sl.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta


bedtools getfasta -fi $1 -bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.bed -name -fo $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.fasta

python3 scripts/revcom_auto.py $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.fasta

rm $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.fasta_ml.fasta

mv $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.fasta_sl.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.fasta


awk 'BEGIN{RS=">"}{print ""$1"\t"$4;}' $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.fasta | tail -n+2 > $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.txt

python3 scripts/keep_unique_seqs.py $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS_UNIQUE.fasta

bedtools getfasta -fi $1 -bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.bed -name -fo $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.fasta

python3 scripts/revcom_auto.py $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.fasta

rm $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.fasta_ml.fasta

mv $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.fasta_sl.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.fasta


awk 'BEGIN{RS=">"}{print ""$1"\t"$4;}' $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.fasta | tail -n+2 > $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.txt

python3 scripts/keep_unique_seqs.py $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS_UNIQUE.fasta

cat $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.fasta > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.fasta

cat $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.txt $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.txt > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.txt

cat $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.txt $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.txt > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.txt

cat $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed

cat $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta

awk '/^>/ {if (seq) {print header"\t"length(seq)}; header=substr($0,2); seq=""; next} {seq=seq $0} END {if (seq) print header"\t"length(seq)}' $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED_LENGTH.txt


# STEP 14c: RUN VMATCH TO FIND THE START/END OLIGOMERS

# D
if [ ! -s $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta ]; then
    echo "$1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta is empty. Skipping vmatch commands."

else
    echo "Processing $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta..."
    
    mkvtree -dna -pl 5 -allout -db $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta

	vmatch -q $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.fasta -complete -h ${19} -d -s -v -showdesc 100 -noevalue -noidentity -noscore $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta > $1_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_START_D_mis${19}.vmatch

	vmatch -q $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.fasta -complete -h ${19} -d -s -v -showdesc 100 -noevalue -noidentity -noscore $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta > $1_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_END_D_mis${19}.vmatch

fi


# P
if [ ! -s $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta ]; then
    echo "$1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta is empty. Skipping vmatch commands."

else
    echo "Processing $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta..."
    
    mkvtree -dna -pl 5 -allout -db $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta

	vmatch -q $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_STARTS.fasta -complete -h ${19} -d -s -v -showdesc 100 -noevalue -noidentity -noscore $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta > $1_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_START_P_mis${19}.vmatch

	vmatch -q $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_POTENTIAL_ENDS.fasta -complete -h ${19} -d -s -v -showdesc 100 -noevalue -noidentity -noscore $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta > $1_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_END_P_mis${19}.vmatch

fi


# STEP 14d: ANALYSE VMATCH OUTPUTS TO GET THE FULL-LENGTH ELEMENTS. SEARCH FOR START AND END 20MERS IN SPECIFIC "LTR" REGIONS. MAXIMUM OR MINIMUM (LAST) PARAMETER TAKES THE FIRST OR LAST START/END OLIGOMER IN LTRS

flag_empty=0  # Flag to track if any file is empty

for file in $1_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_START_D_mis${19}.vmatch $1_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_END_D_mis${19}.vmatch; do
    if [ ! -s "$file" ]; then
        echo "Skipping empty file: $file"
        flag_empty=1  # Mark that at least one file is empty
        continue
    fi

    echo "Processing $file..."
    
    Rscript scripts/vmatch2_2_fulllengthbed_element_specific_start_end_DP_terminal_blast_NEW.R $1_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_START_D_mis${19}.vmatch ${10} ${11} $1_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_END_D_mis${19}.vmatch $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED_LENGTH.txt ${12} ${13} $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

done

# If any file was empty, create sftghr.fasta
if [ "$flag_empty" -eq 1 ]; then
    touch $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed
    echo "Created empty file: $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed"
fi



empty_flag=0  # Flag to track if any file is empty

for file in $1_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_START_P_mis${19}.vmatch $1_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_END_P_mis${19}.vmatch; do
    if [ ! -s "$file" ]; then
        echo "Skipping empty file: $file"
        empty_flag=1  # Mark that at least one file is empty
        continue
    fi

    echo "Processing $file..."
    
    Rscript scripts/vmatch2_2_fulllengthbed_element_specific_start_end_DP_terminal_blast_NEW.R $1_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_START_P_mis${19}.vmatch ${10} ${11} $1_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_END_P_mis${19}.vmatch $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED_LENGTH.txt ${12} ${13} $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

done

# If any file was empty, create sftghr.fasta
if [ "$empty_flag" -eq 1 ]; then
    touch $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed
    echo "Created empty file: $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed"
fi


cat $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

rm $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

rm $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed


ult_empty_flag=0  # Flag to track if any file is empty

file1="$1.DP_FULLLENGTH_BLAST_NONOVERLAPPING.bed"
file2="$1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed"

# Check if either file is empty or missing
if [ ! -s "$file1" ] || [ ! -s "$file2" ]; then
    echo "One or both files are empty or missing."
    ult_empty_flag=1
else
    echo "Processing $file1 and $file2..."
    
    Rscript scripts/get_all_fl.R "$file1" "$file2" \
        "$1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS_COMPLETE.bed" \
        "$1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed" \
        "$1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed"

    sort -k1,1V "$file2" > "$1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS_SORTED.bed"
fi

# If any file was empty, create the output files as empty
if [ "$ult_empty_flag" -eq 1 ]; then
    touch "$1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS_COMPLETE.bed" \
          "$1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed" \
          "$1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed"
    echo "Created empty output files due to missing input."
fi


# STEP 14e: MAKE BED FILES FOR THE 5', 3' LTRs AND THE INTERNAL REGIONS

ult_empty_flag1=0  # Flag to track if any file is empty

file3="$1.D_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.bed"
file4="$1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed"

# Check if either file is empty or missing
if [ ! -s "$file3" ] || [ ! -s "$file4" ]; then
    echo "One or both files are empty or missing."
    ult_empty_flag1=1
else
    echo "Processing $file3 and $file4..."
    
    Rscript scripts/get_ltr_internal_bed_blast_D.R $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.D_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.D_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.D_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

fi

# If any file was empty, create the output files as empty
if [ "$ult_empty_flag1" -eq 1 ]; then
    touch $1.D_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.D_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.D_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed
    echo "Created empty files: $1.D_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.D_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.D_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed"
fi


ult_empty_flag2=0  # Flag to track if any file is empty

file5="$1.P_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.bed"
file6="$1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed"

# Check if either file is empty or missing
if [ ! -s "$file5" ] || [ ! -s "$file6" ]; then
    echo "One or both files are empty or missing."
    ult_empty_flag2=1
else
    echo "Processing $file5 and $file6..."
    
    Rscript scripts/get_ltr_internal_bed_blast_P.R $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_INTERNAL.bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

fi

# If any file was empty, create the output files as empty
if [ "$ult_empty_flag2" -eq 1 ]; then
    touch $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed
    echo "Created empty files: $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed"
fi


# STEP 14f: GET THE FASTA SEQUENCES (BEDTOOLS) FOR THE FULL-LENGTH, 5', 3' LTRs AND THE INTERNAL REGIONS, ALSO RENAME THEM AND CONCATENATE ALL THE REJECTED ELEMENTS FROM THE PREVIOUS STEPS

flag2_empty=0 # Flag to track if any file is empty

for file in $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.D_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.D_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.D_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed; do
    if [ ! -s "$file" ]; then
        echo "Skipping empty file: $file"
        flag2_empty=1  # Mark that at least one file is empty
        continue
    fi

    echo "Processing $file..."

    bedtools getfasta -fi $1 -bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed -nameOnly -fo $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

	bedtools getfasta -fi $1 -bed $1.D_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed -nameOnly -fo $1.D_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

	bedtools getfasta -fi $1 -bed $1.D_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed -nameOnly -fo $1.D_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

	bedtools getfasta -fi $1 -bed $1.D_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed -nameOnly -fo $1.D_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

done

# If any file was empty, create sftghr.fasta
if [ "$flag2_empty" -eq 1 ]; then
    touch $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.D_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.D_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.D_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta
    echo "Created empty files: $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.D_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.D_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.D_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta"
fi


empty_flag2=0 # Flag to track if any file is empty

for file in $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed; do
    if [ ! -s "$file" ]; then
        echo "Skipping empty file: $file"
        empty_flag2=1  # Mark that at least one file is empty
        continue
    fi

    echo "Processing $file..."

    bedtools getfasta -fi $1 -bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed -nameOnly -fo $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

	python3 scripts/revcom_auto2.py $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

	rm $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta_ml.fasta

	mv $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta_sl.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta


	bedtools getfasta -fi $1 -bed $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed -nameOnly -fo $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

	python3 scripts/revcom_auto2.py $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

	rm $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta_ml.fasta

	mv $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta_sl.fasta $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta


	bedtools getfasta -fi $1 -bed $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed -nameOnly -fo $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

	python3 scripts/revcom_auto2.py $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

	rm $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta_ml.fasta

	mv $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta_sl.fasta $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta


	bedtools getfasta -fi $1 -bed $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed -nameOnly -fo $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

	python3 scripts/revcom_auto2.py $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

	rm $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta_ml.fasta

	mv $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta_sl.fasta $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta


done

# If any file was empty, create sftghr.fasta
if [ "$empty_flag2" -eq 1 ]; then
    touch $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta
    echo "Created empty files: $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta"
fi


cat $1.D_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta > $1.DP_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

cat $1.D_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta > $1.DP_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

cat $1.D_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta > $1.DP_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

cat $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

cat $1.D_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed > $1.DP_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

cat $1.D_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed > $1.DP_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

cat $1.D_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed > $1.DP_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

awk 'BEGIN{FS=OFS="\t"}{$9=""; sub("\t\t","\t")}1' $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS_NEW.bed

sort -k1,1V $1.DP_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed > $1.DP_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS_SORTED.bed

cat $1.DP_INTERNAL_RENAMED.fasta $1.DP_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta > $1.DP_INTERNAL_BLAST_TOGETHER.fasta

cat $1.DP_5LTR_RENAMED.fasta $1.DP_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta > $1.DP_5LTR_BLAST_TOGETHER.fasta

cat $1.DP_3LTR_RENAMED.fasta $1.DP_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta > $1.DP_3LTR_BLAST_TOGETHER.fasta

cat $1.DP_FULLLENGTH_RENAMED.fasta $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta > $1.DP_FULLLENGTH_BLAST_TOGETHER.fasta

cat $1.DP_5LTR_BLAST_TOGETHER.fasta $1.DP_3LTR_BLAST_TOGETHER.fasta > $1.DP_ALLLTR_BLAST_TOGETHER.fasta

cat $1.DP_5LTR_RENAMED.bed $1.DP_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed > $1.DP_5LTR_BLAST_TOGETHER.bed

cat $1.DP_3LTR_RENAMED.bed $1.DP_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed > $1.DP_3LTR_BLAST_TOGETHER.bed

cat $1.DP_INTERNAL_RENAMED.bed $1.DP_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed > $1.DP_INTERNAL_BLAST_TOGETHER.bed

awk -F'\t' -v OFS='\t' '{$7=""; $1=$1; print}' $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS_COMPLETE.bed > $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS_COMPLETE_MINUS7.bed

cat $1.DP_FULLLENGTH_RENAMED.bed $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS_COMPLETE_MINUS7.bed > $1.DP_FULLLENGTH_BLAST_TOGETHER.bed

awk '/^>/ {if (seq) {print header"\t"length(seq)}; header=substr($0,2); seq=""; next} {seq=seq $0} END {if (seq) print header"\t"length(seq)}' $1.DP_5LTR_BLAST_TOGETHER.fasta > $1.DP_5LTR_BLAST_TOGETHER_LENGTH.txt

echo "STEP 8: Completed";



echo "STEP 9: Detection of the solo-LTRs. Filtering step is applied based on proximity to PBS and PPT signatures";

# STEP 15: MASK ALL THE FULL-LENGTH ELEMENTS IN THE GENOME AND RUN BLAST TO FIND POTENTIAL SOLO LTRs, ALSO CHECK (VMATCH) IF THERE ARE PBSs AND PPTs UPSTREAM/DOWNSTREAM OR INSIDE THESE ELEMENTS 

### only for masking
awk 'BEGIN{OFS="\t"} {print $1, $2, $3}' $1.DP_FULLLENGTH_BLAST_TOGETHER.bed > $1.DP_FULLLENGTH_BLAST_TOGETHER_SORTED_fixed.bed

bedtools maskfasta -fi $1 -bed $1.DP_FULLLENGTH_BLAST_TOGETHER_SORTED_fixed.bed -fo $1_all_fulllength_masked.fasta

formatdb -i $1_all_fulllength_masked.fasta -p F -o T -n $1_all_fulllength_masked

blastall -p blastn -i $1.DP_5LTR_BLAST_TOGETHER.fasta -d $1_all_fulllength_masked -e 10e-180 -F F -a 7 -m 8 > $1.ALL_5LTR_AGAINST_MG_BLAST_OUTPUT_SOLO_LTR.txt


Rscript scripts/blast_output_analysis_soloLTR.R $1.ALL_5LTR_AGAINST_MG_BLAST_OUTPUT_SOLO_LTR.txt $1.DP_5LTR_BLAST_TOGETHER_LENGTH.txt ${20} ${13} ${12} $1.D_SOLO_LTR_BLAST_NONOVERLAPPING.bed $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.bed $1.P_SOLO_LTR_BLAST_NONOVERLAPPING.bed $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.bed $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.bed $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.bed $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.bed $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.bed

cat $1.D_SOLO_LTR_BLAST_NONOVERLAPPING.bed $1.P_SOLO_LTR_BLAST_NONOVERLAPPING.bed > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING.bed

cat $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.bed $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.bed > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.bed

sort -k1,1V $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING.bed > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_SORTED.bed

sort -k1,1V $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.bed > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_SORTED.bed

bedtools getfasta -fi $1 -bed $1.D_SOLO_LTR_BLAST_NONOVERLAPPING.bed -nameOnly -fo $1.D_SOLO_LTR_BLAST_NONOVERLAPPING.fasta

bedtools getfasta -fi $1 -bed $1.P_SOLO_LTR_BLAST_NONOVERLAPPING.bed -nameOnly -fo $1.P_SOLO_LTR_BLAST_NONOVERLAPPING.fasta

python3 scripts/revcom_auto2.py $1.P_SOLO_LTR_BLAST_NONOVERLAPPING.fasta

rm $1.P_SOLO_LTR_BLAST_NONOVERLAPPING.fasta_ml.fasta

mv $1.P_SOLO_LTR_BLAST_NONOVERLAPPING.fasta_sl.fasta $1.P_SOLO_LTR_BLAST_NONOVERLAPPING.fasta


bedtools getfasta -fi $1 -bed $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.bed -nameOnly -fo $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.fasta

bedtools getfasta -fi $1 -bed $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.bed -nameOnly -fo $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.fasta

python3 scripts/revcom_auto2.py $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.fasta

rm $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.fasta_ml.fasta

mv $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.fasta_sl.fasta $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.fasta

cat $1.D_SOLO_LTR_BLAST_NONOVERLAPPING.fasta $1.P_SOLO_LTR_BLAST_NONOVERLAPPING.fasta > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING.fasta

cat $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.fasta $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.fasta > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.fasta

mkvtree -dna -pl 7 -allout -db $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.fasta

vmatch -q inputs/$2 -complete -h 5 -d -p -s -v -showdesc 100 -noevalue -noidentity -noscore $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.fasta > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_PBS.vmatch

vmatch -q inputs/$3 -complete -h 5 -d -p -s -v -showdesc 100 -noevalue -noidentity -noscore $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS.fasta > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_PPT.vmatch

Rscript scripts/vmatch_solo.R $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_PBS.vmatch $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_PBS.txt

Rscript scripts/vmatch_solo.R $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_PPT.vmatch $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_PPT.txt

cat $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_PBS.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_PPT.txt > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TO_DELETE_PBSPPT.txt

python3 scripts/remove_prime_solo.py $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING.fasta $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TO_DELETE_PBSPPT.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_CLEAR_PBSPPT_ml.fasta

awk '/^>/ { if(NR>1) print "";  printf("%s\n",$0); next; } { printf("%s",$0);}  END {printf("\n");}' $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_CLEAR_PBSPPT_ml.fasta > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_CLEAR_PBSPPT.fasta

awk 'NR == FNR {a[$1]; next} !($6 in a)' $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TO_DELETE_PBSPPT.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING.bed > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_CLEAR_PBSPPT.bed 

echo "STEP 9: Completed";



echo "STEP 10: TSD analysis";

# STEP 16: TAKE THE TSDs AND MAKE A TABLE WITH THEIR INFORMATION [FULL-LENGTH ID, UPSTREAM 5MER, DOWNSTREAM 5MER, SAME TDS Y/N, TSD SEQUENCE]

bedtools getfasta -fi $1 -bed $1.D_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.bed -nameOnly -fo $1.D_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.fasta

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.D_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.fasta > $1.D_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.txt


bedtools getfasta -fi $1 -bed $1.D_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.bed -nameOnly -fo $1.D_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.fasta

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.D_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.fasta > $1.D_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.txt


bedtools getfasta -fi $1 -bed $1.P_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.bed -nameOnly -fo $1.P_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.fasta

python3 scripts/revcom_auto2.py $1.P_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.fasta

rm $1.P_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.fasta_ml.fasta

mv $1.P_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.fasta_sl.fasta $1.P_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.fasta

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.P_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.fasta > $1.P_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.txt


bedtools getfasta -fi $1 -bed $1.P_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.bed -nameOnly -fo $1.P_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.fasta

python3 scripts/revcom_auto2.py $1.P_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.fasta

rm $1.P_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.fasta_ml.fasta

mv $1.P_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.fasta_sl.fasta $1.P_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.fasta

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.P_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.fasta > $1.P_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.txt


bedtools getfasta -fi $1 -bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.bed -nameOnly -fo $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta > $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.txt


bedtools getfasta -fi $1 -bed $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.bed -nameOnly -fo $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta > $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.txt


bedtools getfasta -fi $1 -bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.bed -nameOnly -fo $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta

python3 scripts/revcom_auto2.py $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta

rm $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta_ml.fasta

mv $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta_sl.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta > $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.txt


bedtools getfasta -fi $1 -bed $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.bed -nameOnly -fo $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta

python3 scripts/revcom_auto2.py $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta

rm $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta_ml.fasta

mv $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta_sl.fasta $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta > $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.txt



bedtools getfasta -fi $1 -bed $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.bed -nameOnly -fo $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta > $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.txt



bedtools getfasta -fi $1 -bed $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.bed -nameOnly -fo $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta > $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.txt

bedtools getfasta -fi $1 -bed $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.bed -nameOnly -fo $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta



python3 scripts/revcom_auto2.py $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta

rm $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta_ml.fasta

mv $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta_sl.fasta $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.fasta > $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.txt



bedtools getfasta -fi $1 -bed $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.bed -nameOnly -fo $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta

python3 scripts/revcom_auto2.py $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta

rm $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta_ml.fasta

mv $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta_sl.fasta $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.fasta > $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.txt


ult_red_flag=0  # Flag to track if any file is empty

file_blast_tsd1="$1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.txt"
file_blast_tsd2="$1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.txt"
file_blast_tsd3="$1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.txt"
file_blast_tsd4="$1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.txt"

# Check if either file is empty or missing
if [ ! -s "$file_blast_tsd1" ] || [ ! -s "$file_blast_tsd2" ] || [ ! -s "$file_blast_tsd3" ] || [ ! -s "$file_blast_tsd4" ]; then
    echo "One or more files are empty or missing."
    ult_red_flag=1
else
    echo "Processing $file_blast_tsd1, $file_blast_tsd1, $file_blast_tsd3 and $file_blast_tsd4..."

    Rscript scripts/tsd_analysis.R $1.D_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.txt $1.D_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.txt $1.P_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.txt $1.P_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.txt $1.DP_FULLLENGTH_TSD_TABLE.txt $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.txt $1.D_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.txt $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.txt $1.P_FULLLENGTH_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.txt $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_TSD_TABLE.txt $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.txt $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.txt $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.txt $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD.txt

fi


# If any file was empty, create the output files as empty
if [ "$ult_red_flag" -eq 1 ]; then 

  Rscript scripts/tsd_analysis_blastless_fl.R $1.D_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.txt $1.D_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.txt $1.P_FULLLENGTH_NEW_PLUS_TSD_LEFTV2.txt $1.P_FULLLENGTH_NEW_PLUS_TSD_RIGHTV3.txt $1.DP_FULLLENGTH_TSD_TABLE.txt $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.txt $1.D_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.txt $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_LEFTV2.txt $1.P_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TSD_RIGHTV3.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD.txt

  touch $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_TSD_TABLE.txt
  echo "Created empty file: $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_TSD_TABLE.txt"

fi


awk 'NR == FNR {a[$1]; next} !($1 in a)' $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TO_DELETE_PBSPPT.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD.txt > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT.txt

awk 'NR == FNR {a[$1]; next} !($1 in a)' $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TO_DELETE_PBSPPT.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD.txt > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT.txt

awk -F '\t' '{print $1}' $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT.txt > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT_TO_FASTA.txt

awk -F '\t' '{print $1}' $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT.txt > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT_TO_FASTA.txt


grep -w -A 1 -f $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT_TO_FASTA.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_CLEAR_PBSPPT.fasta > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT.fasta

awk '!/--/' $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT.fasta > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT_NEW.fasta

rm $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT.fasta

grep -w -A 1 -f $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT_TO_FASTA.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_CLEAR_PBSPPT.fasta > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT.fasta

awk '!/--/' $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT.fasta > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT_NEW.fasta

rm $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT.fasta


awk 'NR == FNR {a[$1]; next} ($4 in a)' $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_CLEAR_PBSPPT.bed  > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT.bed

awk 'NR == FNR {a[$1]; next} ($4 in a)' $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_CLEAR_PBSPPT.bed  > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT.bed

cat $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT.txt > $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_ALL_TSD_CLEAR_PBSPPT.txt


cat $1.DP_FULLLENGTH_TSD_TABLE.txt $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_TSD_TABLE.txt > $1.DP_FULLLENGTH_BLAST_TOGETHER_TSD_TABLE.txt

cat $1.DP_FULLLENGTH_TSD_TABLE.txt $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_TSD_TABLE.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_ALL_TSD_CLEAR_PBSPPT.txt > $1.DP_ULTIMATE_TSD_TABLE.txt

echo "STEP 10: Completed";



echo "STEP 11: Detection of the LTR retrotransposon related genes in the internal domain of the elements";

# STEP 17: RUN GETORF COMMAND FROM EMBOSS TO FIND THE ORFS IN THE INTERNAL DOMAIN OF TEKAY ELEMENTS
# STEP 18: RUN HMMSCAN COMMAND FROM HMMER TO FIND THE HMMS IN ORFS OF THE INTERNAL DOMAINS OF TEKAY ELEMENTS
# STEP 19: ANALYSE HMMSCAN OUTPUT

getorf -sequence $1.DP_INTERNAL_BLAST_TOGETHER.fasta -minsize 300 -noreverse -find 0 --outseq $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300

grep ">" $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300 | sed 's,>,,g' > $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_IDs.txt

awk '!/^>/ { printf "%s", $0; n = "\n" } /^>/ { print n $0; n = "" } END { printf "%s", n }' $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300 > $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta


hmmpress -f inputs/${21} 

hmmscan -o $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22} --tblout $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.tbl --domtblout $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl --max -E ${22} --domE ${22} --incE ${22} --incdomE ${22} inputs/${21} $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta

grep NAME inputs/${21} | awk 'BEGIN {OFS="\t"};{print $4}' > ${21}_NAME.txt

grep LENG inputs/${21} | awk 'BEGIN {OFS="\t"};{print $4}' > ${21}_LENG.txt

paste ${21}_NAME.txt ${21}_LENG.txt > ${21}_NAME_AND_LENGTH.txt

rm ${21}_NAME.txt

rm ${21}_LENG.txt


Rscript scripts/hmm_domtbl_analysis.R $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_HMM_AA.bed $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_IDs.txt ${21}_NAME_AND_LENGTH.txt $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_COUNT_TABLE.txt $1.DP_5LTR_BLAST_TOGETHER_LENGTH.txt ${12}_ $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_D_HMM_BED.bed $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_P_HMM_BED.bed $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_HMMTABLE.txt

bedtools getfasta -fi $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta -bed $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_HMM_AA.bed -nameOnly -fo $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_HMM_AA.fasta

cat $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_D_HMM_BED.bed $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_P_HMM_BED.bed > $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_DP_HMM_BED.bed

bedtools getfasta -fi $1 -bed $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_D_HMM_BED.bed -nameOnly -fo $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_D_HMM_FASTA.fasta

bedtools getfasta -fi $1 -bed $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_P_HMM_BED.bed -nameOnly -fo $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_P_HMM_FASTA.fasta


python3 scripts/revcom_auto2.py $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_P_HMM_FASTA.fasta

rm $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_P_HMM_FASTA.fasta_ml.fasta

mv $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_P_HMM_FASTA.fasta_sl.fasta $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_P_HMM_FASTA.fasta


cat $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_D_HMM_FASTA.fasta $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_P_HMM_FASTA.fasta > $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_DP_HMM_FASTA.fasta

python3 scripts/translate_dna.py $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_DP_HMM_FASTA.fasta

echo "STEP 11: Completed";



echo "STEP 12: Calculation of the percentage identity score of the LTRs and creating the summary tables";

# STEP 20: PERCENTAGE IDENTITY SCORE
# STEP 21: SUMMARY TABLES

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.DP_5LTR_BLAST_TOGETHER.fasta > $1.DP_5LTR_BLAST_TOGETHER_TABLE.txt

awk 'BEGIN{RS=">"; ORS=""} NR>1 {h=$1; s=$0; sub(/^[^\n]*\n/,"",s); gsub(/\n/,"",s); print h "\t" s "\n"}' $1.DP_3LTR_BLAST_TOGETHER.fasta > $1.DP_3LTR_BLAST_TOGETHER_TABLE.txt


Rscript scripts/pid.R $1.DP_5LTR_BLAST_TOGETHER_TABLE.txt $1.DP_3LTR_BLAST_TOGETHER_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID1_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID2_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID3_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID4_TABLE.txt $1_pid1.png $1_pid2.png $1_pid3.png $1_pid4.png


ult_empty_flag3=0  # Flag to track if any file is empty

file7="$1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS_COMPLETE.bed"
file8="$1.DP_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed"
file9="$1.DP_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed"

# Check if either file is empty or missing
if [ ! -s "$file7" ] || [ ! -s "$file8" ] || [ ! -s "$file9" ]; then
    echo "One or both files are empty or missing."
    ult_empty_flag3=1
else
    echo "Processing $file7, $file8 and $file9..."
    
    Rscript scripts/summary_table.R $1.DP_FULLLENGTH_RENAMED.bed $1.DP_5LTR_RENAMED.bed $1.DP_3LTR_RENAMED.bed $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS_COMPLETE.bed $1.DP_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.DP_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed $1.DP_FULLLENGTH_BLAST_TOGETHER_PID1_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID2_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID3_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID4_TABLE.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_CLEAR_PBSPPT.bed $1.DP_ULTIMATE_TSD_TABLE.txt ${12} $1.DP_FULLLENGTH_AND_SOLO_SUMMARY_TABLE.txt $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_HMMTABLE.txt $1.DP_FULLLENGTH_AND_HMM_SUMMARY_TABLE_ALLPID.txt

fi

# If any file was empty, create the output files as empty
if [ "$ult_empty_flag3" -eq 1 ]; then
    
	Rscript scripts/blastless_summary.R $1.DP_FULLLENGTH_RENAMED.bed $1.DP_5LTR_RENAMED.bed $1.DP_3LTR_RENAMED.bed $1.DP_FULLLENGTH_BLAST_TOGETHER_PID1_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID2_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID3_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID4_TABLE.txt $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_CLEAR_PBSPPT.bed $1.DP_ULTIMATE_TSD_TABLE.txt ${12} $1.DP_FULLLENGTH_AND_SOLO_SUMMARY_TABLE.txt $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E${22}incE${22}.domtbl_HMMTABLE.txt $1.DP_FULLLENGTH_AND_HMM_SUMMARY_TABLE_ALLPID.txt

fi

echo "STEP 12: Completed";



echo "Deleting intermediate files!"

rm *.al1

rm *.bck

rm *.bwt

rm *.des

rm *.fai

rm *.lcp

rm *.llv

rm *.ois

rm *.prj

rm *.sds

rm *.skp

rm *.ssp

rm *.sti1

rm *.suf

rm *.tis

rm *_masked.fasta

rm *_MASKED.fasta

rm *_ml.fasta

rm *_FULL_D.bed

rm *_FULL_P.bed

rm *_UNIQUE.bed

rm *_r10k.txt

rm *_r10k_v.txt

rm *_l10k_v.txt

rm *.PBS_2_PPT_D_EVERYTHING.txt

rm *.PPT_2_PBS_P_EVERYTHING.txt

rm *.PBS_2_PPT_D_INTERSECT_NEW.bed

rm *.PPT_2_PBS_P_INTERSECT_NEW.bed

rm *.PBS_2_PPT_D_REJECTED.bed 

rm *.PPT_2_PBS_P_REJECTED.bed

rm *_DISTANCE.txt

rm *_INTERSECT.bed

rm *.INTERSECT_D_2_P.txt

rm *.INTERSECT_P_2_D.txt

rm *_FULL_DP.bed

rm *_SORTED.bed

rm $1.ALL.PBSNPPT_D_EXTENDED_INTERNAL_CLEAN.bed

rm $1.ALL.PBSNPPT_P_EXTENDED_INTERNAL_CLEAN.bed

rm *_POTENTIAL_STARTS.bed

rm *_POTENTIAL_STARTS.fasta

rm *_POTENTIAL_STARTS.txt

rm *.PBSNPPT_D_OUTSIDE_INTERNAL_CLEAN.bed

rm *.PPTNPBS_P_OUTSIDE_INTERNAL_CLEAN.bed

rm *_UNIQUE.fasta

rm *_POTENTIAL_ENDS.bed

rm *_POTENTIAL_ENDS.fasta

rm *_POTENTIAL_ENDS.txt

rm *_OUTSIDE_D_ELEMENTS.fasta

rm *_ELEMENTS.fasta

rm *_FULLLENGTH.bed

rm *_5LTR.bed

rm *_3LTR.bed

rm *_INTERNAL.bed

rm *_FULLLENGTH.fasta

rm *_5LTR.fasta

rm *_3LTR.fasta

rm *_INTERNAL.fasta

rm *_LEFTV2.bed

rm *_RIGHTV3.bed

rm *_LEFTV2.fasta

rm *_RIGHTV3.fasta

rm *_LEFTV2.txt

rm *_RIGHTV3.txt

rm *_RENAME.txt

rm *.nsq

rm *.nin

rm *.nhr

rm *.D_FULLLENGTH_BLAST_NONOVERLAPPING.bed

rm *.P_FULLLENGTH_BLAST_NONOVERLAPPING.bed

rm *.D_FULLLENGTH_BLAST_NONOVERLAPPING.fasta

rm *.P_FULLLENGTH_BLAST_NONOVERLAPPING.fasta

rm *_sl.fasta

rm *_LENGTH.txt

rm *.D_SOLO_LTR_BLAST_NONOVERLAPPING.bed

rm *.P_SOLO_LTR_BLAST_NONOVERLAPPING.bed

rm *.D_SOLO_LTR_BLAST_NONOVERLAPPING.fasta

rm *.P_SOLO_LTR_BLAST_NONOVERLAPPING.fasta

rm *_PLUS.bed

rm *_PLUS.fasta

rm *_PPT.txt

rm *.DP_FULLLENGTH_TSD_TABLE.txt

rm *.DP_FULLLENGTH_BLAST_NONOVERLAPPING_TSD_TABLE.txt

rm *.DP_SOLO_LTR_BLAST_NONOVERLAPPING_PLUS_TO_DELETE_PBSPPT.txt

rm *_TO_FASTA.txt

rm *.ORF300

rm *.tbl

rm *.E${22}incE${22}

rm inputs/*.h3p

rm inputs/*.h3m

rm inputs/*.h3i

rm inputs/*.h3f

rm *_D_HMM_BED.bed

rm *_P_HMM_BED.bed

rm *_D_HMM_FASTA.fasta

rm *_P_HMM_FASTA.fasta

rm *.vmatch

rm *.nsd

rm *.nsi

rm *.D_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

rm *.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

rm *.D_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

rm *.P_3LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

rm *.D_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

rm *.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

rm *.D_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

rm *.P_5LTR_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

rm *.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed

rm *.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.bed

rm *.D_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta

rm *.P_FULLLENGTH_BLAST_NONOVERLAPPING_EXTENDED.fasta

rm *.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

rm *.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

rm *.D_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

rm *.P_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

rm *.D_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

rm *.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.bed

rm *.D_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

rm *.P_INTERNAL_BLAST_NONOVERLAPPING_SPECIFIC_ENDS.fasta

rm formatdb.log 

rm error.log

echo "Intermediate files deleted!"




echo "Assembly: $1";

echo "PBS signature: $2";

echo "PPT signature: $3";

echo "Searching Regions (bedtools window): $4";

echo "Minimum Internal Length: $5";

echo "Maximum Internal Length: $6";

echo "Extend Internal: $7";

echo "Length of Start/End Oligomers: $8";

echo "Mismatches of Start/End Oligomers: $9";

echo "Minimum LTR Length: ${10}";

echo "Maximum LTR Length: ${11}";

echo "Species code: ${12}";

echo "LTR retrotransposon lineage: ${13}"

echo "BLAST FULL-LENGTH Coverage (Minimum value): ${14}";

echo "BLAST Minimum Signature Coordinate: ${15}"

echo "BLAST Maximum Signature Coordinate: ${16}"

echo "BLAST PBS Signature Mismatches: ${17}"

echo "BLAST PPT Signature Mismatches: ${18}"

echo "BLAST Mismatches of Start/End Oligomers: ${19}";

echo "BLAST SOLO-LTR Coverage (Minimum value): ${20}";

echo "ORF HMM DATABASE: ${21}";

echo "HMMSCAN E-VALUE: ${22}";



end=$(date +%s)

runtime=$((end - start))

echo "Running time so far: $((runtime / 60)) min"


a=($(wc $1.DP_FULLLENGTH_RENAMED.bed))

b=($(wc $1.DP_FULLLENGTH_BLAST_NONOVERLAPPING_SPECIFIC_ENDS_COMPLETE.bed))

c=($(wc $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT.bed))

d=($(wc $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT.bed))


echo "Thank you for using our tool! You retrieved ${a[0]} full-length elements based on the structural step and ${b[0]} full-length elements from the homology step. Additionally, ${c[0]} solo-LTRs with TSDs and ${d[0]} without TSDs were identified."


mkdir ${12}.main.outputs

mv $1.ALL.PBSNPPT_DP_OUTSIDE_INTERNAL_PROXIMAL_ELEMENTS.bed $1.ALL.PBSNPPT_DP_OUTSIDE_INTERNAL_ORPHAN_OLIGOMERS.bed $1.ALL.DP_REJECTED_ELEMENTS.bed \
   $1.DP_INTERNAL_BLAST_TOGETHER.fasta $1.DP_5LTR_BLAST_TOGETHER.fasta $1.DP_3LTR_BLAST_TOGETHER.fasta $1.DP_FULLLENGTH_BLAST_TOGETHER.fasta $1.DP_5LTR_BLAST_TOGETHER.bed $1.DP_3LTR_BLAST_TOGETHER.bed $1.DP_INTERNAL_BLAST_TOGETHER.bed $1.DP_FULLLENGTH_BLAST_TOGETHER.bed \
   $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT_NEW.fasta $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT_NEW.fasta $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITHOUT_TSD_CLEAR_PBSPPT.bed $1.DP_SOLO_LTR_BLAST_NONOVERLAPPING_TSD_TABLE_WITH_TSD_CLEAR_PBSPPT.bed $1.DP_FULLLENGTH_BLAST_TOGETHER_TSD_TABLE.txt \
   $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E0.01incE0.01.domtbl_HMM_AA.bed $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E0.01incE0.01.domtbl_HMMTABLE.txt $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E0.01incE0.01.domtbl_DP_HMM_BED.bed $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E0.01incE0.01.domtbl_DP_HMM_FASTA.fasta $1.DP_INTERNAL_BLAST_TOGETHER.fasta.ORF300_SL.fasta.hmmscanned.E0.01incE0.01.domtbl_DP_HMM_FASTA.fasta_PROTEIN.fasta \
   $1.DP_FULLLENGTH_BLAST_TOGETHER_PID1_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID2_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID3_TABLE.txt $1.DP_FULLLENGTH_BLAST_TOGETHER_PID4_TABLE.txt \
   $1_pid1.png $1_pid2.png $1_pid3.png $1_pid4.png \
   $1.DP_FULLLENGTH_AND_SOLO_SUMMARY_TABLE.txt $1.DP_FULLLENGTH_AND_HMM_SUMMARY_TABLE_ALLPID.txt ${12}.main.outputs/

cd ${12}.main.outputs


cd ../

mkdir ${12}.side.outputs

mv $1* ${12}.side.outputs

cd ${12}.side.outputs
